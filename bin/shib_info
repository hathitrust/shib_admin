#!/usr/bin/env ruby

require 'net/http'
require 'nokogiri'
require 'optparse'

# get args
domain_parse = true
verbose = false
OptionParser.new do |opts|
  opts.banner = <<usage

Usage: shib_info [-v] [ entityID_substring ]

Prints a list of possible entityID matches, or additional information on the
entitly if there is exactly one match.

Use without options to see full list of InCommon IdPs.

usage

  opts.on("-v", "Print XML dump of full EntityDescriptor") do |v|
    verbose = v
  end

end.parse!

q = ARGV[0]

# fetch metadata, find entityID matches
doc = Nokogiri::XML(Net::HTTP.get(URI('http://md.incommon.org/InCommon/InCommon-metadata-idp-only.xml')))
doc.remove_namespaces! # until/unless we figure out how to do this right

# search for matching entitly ids, limit search to SSO providers
eids = doc.xpath("//EntityDescriptor[contains(@entityID,'#{q}')][.//SingleSignOnService]/@entityID").map { |attr| attr.value }

# no match
if eids.size < 1
  puts "#{q}: no match"
# many matches, list choices
elsif eids.size > 1
  puts eids
# one match, print IdP info
else
  eid = eids[0]

  puts "EntityID: #{eid}"
  print 'Support Contact: '
  support_addresses = doc.xpath("//EntityDescriptor[@entityID='#{eid}']/ContactPerson[@contactType='support']/EmailAddress")
  if !support_addresses.empty?
    print support_addresses.map { |node| node.inner_text }.join(', ') + ' '
  else
    print "NONE "
  end
  print 'Technical Contact: '
  support_addresses = doc.xpath("//EntityDescriptor[@entityID='#{eid}']/ContactPerson[@contactType='technical']/EmailAddress")
  if !support_addresses.empty?
    print support_addresses.map { |node| node.inner_text }.join(', ') + ' '
  else
    print "NONE "
  end
  puts

  if verbose
    puts 'Full EntityDescriptor:'
    puts doc.xpath("//EntityDescriptor[@entityID='#{eid}']")
  end
end
